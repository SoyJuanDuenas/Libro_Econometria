{
  "hash": "ceb4a8332468482f7c18c31a4207e376",
  "result": {
    "markdown": "---\ntitle: \"Primeros Pasos\"\n---\n\n\n## Acerca de R\n\nR es un lenguaje de programación y entorno de desarrollo estadistico gratuito y de codigo abierto, cualquier persona puede descargarlo, utilizarlo y modificarlo. Esto permite que tenga una gran comunidad y documentación bien detallada de cada una de sus funcionalidades y paquetes, R es un lenguaje orientado a objetos lo que significa que los datos se organizan en objetos que se pueden manipular y analiza., R cuenta con una interfaz gráfica de usuario llamada RStudio que facilita el trabajo con el lenguaje y permite la creación y visualización de datos de manera sencilla.\n\nR permite hacer diferentes tipos de analisis, Estadistica Descriptiva, Estadistica Bayesiana, Modelos Estado Espacio, entre otros. Es decir en R podemos hacer macroeconometria, microeconometria, econometría fianciera, evaluación de impacto, econometría bayesiana, econometria espacial entre otros analisis estadisticos.\n\n## Interfaz de RStudio\n\nRStudio proporciona una interfaz gráfica de usuario (GUI) que facilita el trabajo con R, lo que lo hace más accesible para los usuarios que no están familiarizados con la programación en línea de comandos.\n\nAl ingresar a RStudio nos vamos a encontrar con cuatro principales paneles:\n\n![](Vista%20General%20RStudio.png)\n\n1.  **Editor :** En el editor será donde colocaremos el codigo y los comandos de ejecución.\n2.  **Consola:** Alli veremos los resultados o los outputs del codigo.\n3.  **Espacio de Trabajo:** Aqui podemos ver el historial de comandos que hemos usado, las diferentes variables, datasets, objetos y funciones que hemos declarado entre otras cosas\n4.  **Archivos / graficas / paquetes:** Allí podremos visualizar los plots que generemos en el codigo, las librerias que tengamos instaladas, los archivos de nuestro PC entre otros\n\nNos vamos a centrar en el trabajo que se hace en el primer panel.\n\n## Comentarios\n\nEs una buena practica comentar nuestro codigo, esto significa ir colocando texto no ejecutable que explique que esta haciendo nuestro codigo, esto nos facilitará a nosotros y a otras personas más adelante corregir y entender lo que estamos haciendo, para comentar el codigo usamos el `#`, el texto que se encuentre despues del numeral no será ejecutado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Esto es un comentario\n```\n:::\n\n\n## Paquetes y limpieza de entorno\n\nR siempre guarda las diferentes variables, datasets entre otros objetos, es por esto que es una buena practica al principio de cada codigo limipar nuestro entorno, esto lo hacemos con el siguiente comando.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove(list = ls())\n```\n:::\n\n\nDado que R es un lenguaje Open Source, los usuarios pueden crear paquetes para facilitar o realizar nuevas operaciones que R base no puede. Sin embargo, para hacer uso de estos paquetes debemos instalarlos y luego activarlos, la instalación solo se hace una vez mientras que la activación si debe hacerse al abrir RStudio de nuevo. Es una buena practica activar todos los paquetes en las primeras lineas de codigo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(repos = c(CRAN = \"http://cran.rstudio.com\"))\ninstall.packages(\"dplyr\")\ninstall.packages(\"ggplot2\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n:::\n\n\n## Operadores Aritmeticos\n\nR incluye varios operadores aritmeticos que se utilizan para realizar operaciones matematicas. Los operadores aritmeticos incluyen:\n\n-   `+` : Suma dos números\n\n-   `-` : Resta dos números\n\n-   `*` : Multiplica dos números\n\n-   `/` : Divide dos números\n\n-   `**` : Eleva un número a una potencia\n\n## Variables y tipos de objetos\n\nDiremos que una variable es un \"contenedor de información\" en la que podemos \"guardar\" diferentes objetos, generalmente se escriben en minúscula, sin espacios ni tildes, comas, puntos, signos de interrogación o cualquier otro caracter a excepción del guión bajo, para declarar variable en R podemos usar \\<- como tambien =\n\nPara notación de este libro usaremos unicamente el igual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre_de_la_variable <- \"Valor de la variable\"\nnombre_de_la_variable = \"Valor de la variable\"\n```\n:::\n\n\npara visualizar nuestra variable en la consola (Panel #2) debemos llamarla de nuevo, utilizar la función print o podemos usar un ; y volver a llamar la función en la misma linea\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre_de_la_variable\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Valor de la variable\"\n```\n:::\n\n```{.r .cell-code}\nprint(nombre_de_la_variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Valor de la variable\"\n```\n:::\n\n```{.r .cell-code}\nnombre_de_la_variable = \"Valor de la variable\"; nombre_de_la_variable\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Valor de la variable\"\n```\n:::\n:::\n\n\nLos objetos que guardamos en las variables pueden ser de diferentes tipos y en función de esto la forma de guardarlos cambia, en R existen los siguientes tipos de objetos:\n\n-   **Numericos:** datos que tienen numeros, pueden ser continuos (admiten decimales) o discretos (no admiten decimales)\n\n-   **Logicos:** Solo admiten dos valores, `True` o `False`\n\n-   **Caracteres:** Cadena de caracteres, lease palabras\n\n-   **Complejos:** Objetos que pertenecen al plano complejo\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjeto_numeric = 3\nobjeto_logic = FALSE\nobjeto_character = \"Hola Mundo\"\nobjeto_complex = 1+0i\n```\n:::\n\n\nPara verificar de que tipo o clase es un objeto podemos usar la función `class`, puede darse el caso de que se necesite convertir un objeto de un tipo a otro tipo, para esto usamos alguna de las siguientes funciones según corresponda\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nas.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"\n```\n:::\n:::\n\n\nPara hacer operaciones entre variables nos aseguramos que las variables sean de tipo numerico y operamos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = 5\nb = 7\n\nc = a + b\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\n## Estructuras de datos\n\nUna colección es un objeto que puede contener varios valores o elementos en determinado orden o estructura, Las colecciones son fundamentales y se utilizan para almacenar y manupular datos\n\n### Vectores\n\nLos vectores son entes matematicos que se usan para guardar objetos de cierto tipo especifico, para crear vectores en R debemos usar el comando `c`, los vectores nos permiten hacer operaciones entre varios datos al mismo tiempo sin tener que recurrir a bucles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_primer_vector = c(25,5,3,6,3,6)\nvector_dos = c(\"Hola\", \"mundo\")\nvector_tres = c(FALSE, TRUE, FALSE, TRUE)\n```\n:::\n\n\nComo los vectores solamente pueden guardar un tipo de dato, si llegamos a introducir diferentes tipos de datos, el vector automaticamente va a transformar estos datos para que el vector quede solamente en función de un tipo de dato.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1.7, \"a\")   ## character\ny <- c(TRUE, 2)    ## numeric\ny <- c(\"a\", TRUE)  ## character\n```\n:::\n\n\nPodemos crear vectores con determinadas caracteristicas de manera eficiente, por ejemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Crear un vector secuencia 1 a 1.\nDias = 0:15; Dias\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n```\n:::\n\n```{.r .cell-code}\n#Crar un vector secuencia que avance cada j unidades: seq(a,b,j)\nMedicion = seq(1,5, 0.5); Medicion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n```\n:::\n\n```{.r .cell-code}\n#Crear un vector donde los objetos se repiten n veces: rep(objeto,n)\nNumerico = rep(1,10); Numerico\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\n#Crear un vector de repeticiones\nDummy = c(rep(0,5), rep(1,10), rep(0,5)); Dummy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0\n```\n:::\n:::\n\n\nPara concatenar vectores simplemente debemos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_a = c(2,54,3)\nvector_b = c(3,7,8)\nvector_c = c(vector_a, vector_b); vector_c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 54  3  3  7  8\n```\n:::\n:::\n\n\nLas operaciones con vectores funcionan de manera similar a las operaciones con variables, en ultimas seguimos operando variables solo que en este caso las variables no contienen un solo valor sino contienen un vector de valores. Los vectores entre si deben ser iguales o multiplos. En caso de ser iguales se hará la operación uno a uno, en cambio si son multiplos se repetira la operación en los diferentes vectores, tal que:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Operación uno a uno\nvector_a = c(2,54,3)\nvector_b = c(3,7,8)\nvector_c = vector_a + vector_b; vector_c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5 61 11\n```\n:::\n\n```{.r .cell-code}\n#Operación entre multiplos\nvector_a = c(2,54,3,4,8,5)\nvector_b = c(3,7,8)\nvector_c = vector_a + vector_b; vector_c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5 61 11  7 15 13\n```\n:::\n:::\n\n\npodemos hacer estadistica descriptiva de los vectores usando la función summary\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(vector_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   2.00    3.25    4.50   12.67    7.25   54.00 \n```\n:::\n:::\n\n\nentre otros posibles metodos de la clase vector tenemos\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#describir cuales son los elementos que no se repiten del vector\nunique(vector_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 54  3  4  8  5\n```\n:::\n\n```{.r .cell-code}\n#Ordenar elementos de menor a mayor\nsort(vector_a)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4  5  8 54\n```\n:::\n\n```{.r .cell-code}\n#Posición ordenada de menor a mayor\norder(vector_a) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 4 6 5 2\n```\n:::\n\n```{.r .cell-code}\n#Ordenar elementos de mayor a menor:\nsort(vector_a, decreasing = TRUE)       \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54  8  5  4  3  2\n```\n:::\n:::\n\n\n### Matrices\n\nUna matriz es una colección de datos bidimensional que consiste en un conjunto de elementos organizados en filas y columnas. Se puede representar como una tabla o cuadrícula de números o valores. Cada elemento en la matriz se identifica por su posición que se determina por el número de fila y columna.\n\nPara crear matrices en R podemos hacerlo directamente o a partir de vectores previamente creados, para crear matrices directamente usamos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMAT1=matrix(1:10,nrow = 5,byrow = TRUE);MAT1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n[4,]    7    8\n[5,]    9   10\n```\n:::\n\n```{.r .cell-code}\nMAT2=matrix(10:19,ncol=5, nrow = 2, byrow = FALSE);MAT2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   10   12   14   16   18\n[2,]   11   13   15   17   19\n```\n:::\n:::\n\n\nDonde el primer parametro corresponde a con que vamos a llenar esas matrices, este intervalo debe ser multiplo del número de filas o columnas que queremos crear, el segundo parametro corresponderá a si vamos a hacer la creación de la matriz desde la columna o desde las filas, podemos tambien hacerlo desde ambas.\n\nAhora bien, si queremos crear matrices a partir de vectores ya establecidos previamente usaremos el siguiente codigo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = c(1,4,5,7,9,7,10,6,5,7,9)\nb = c(3,4,6,8,2,3,11,1,2,5,6)\nMAT3 = cbind(a,b); MAT3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       a  b\n [1,]  1  3\n [2,]  4  4\n [3,]  5  6\n [4,]  7  8\n [5,]  9  2\n [6,]  7  3\n [7,] 10 11\n [8,]  6  1\n [9,]  5  2\n[10,]  7  5\n[11,]  9  6\n```\n:::\n\n```{.r .cell-code}\nMAT4 = rbind(a,b); MAT4 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\na    1    4    5    7    9    7   10    6    5     7     9\nb    3    4    6    8    2    3   11    1    2     5     6\n```\n:::\n:::\n\n\nComo nos podemos dar cuenta al usar vectores tambien podemos crear las matrices desde las filas o desde las columnas.\n\nLas matrices tienen formas de operarse de manera diferente a los escalares o constantes, por lo cual vamos a detallar cada una de las operaciones principales:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Suma escalar - matriz\nMAT1 + 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   11   12\n[2,]   13   14\n[3,]   15   16\n[4,]   17   18\n[5,]   19   20\n```\n:::\n\n```{.r .cell-code}\n#Suma matriz - matriz\nMAT3 + t(MAT4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       a  b\n [1,]  2  6\n [2,]  8  8\n [3,] 10 12\n [4,] 14 16\n [5,] 18  4\n [6,] 14  6\n [7,] 20 22\n [8,] 12  2\n [9,] 10  4\n[10,] 14 10\n[11,] 18 12\n```\n:::\n\n```{.r .cell-code}\n#Multiplicar escalar - matriz\nMAT3*10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        a   b\n [1,]  10  30\n [2,]  40  40\n [3,]  50  60\n [4,]  70  80\n [5,]  90  20\n [6,]  70  30\n [7,] 100 110\n [8,]  60  10\n [9,]  50  20\n[10,]  70  50\n[11,]  90  60\n```\n:::\n:::\n\n\nPodemos crerar trambien matrices especiales\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Matriz Transpuesta: t() \nt(MAT1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n:::\n\n```{.r .cell-code}\n#Matriz identidad: diag()\ndiag(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n:::\n\n```{.r .cell-code}\n#Matriz diagonal: diag()\nMat_diag = diag(1:10)\n```\n:::\n\n\nFinalmente calcularemos la multiplicación matricial que recordemos no se hace punto a punto sino por medio de un proceso diferente, tambien la inversa de una matriz y su determinante\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Producto de matrices\ndim(MAT3) #conocer las dimensiones de una matriz: 11x2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11  2\n```\n:::\n\n```{.r .cell-code}\ndim(MAT4) #2x11, son multiplicable. por ende:\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 11\n```\n:::\n\n```{.r .cell-code}\nMAT3%*%MAT4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]   10   16   23   31   15   16   43    9   11    22    27\n [2,]   16   32   44   60   44   40   84   28   28    48    60\n [3,]   23   44   61   83   57   53  116   36   37    65    81\n [4,]   31   60   83  113   79   73  158   50   51    89   111\n [5,]   15   44   57   79   85   69  112   56   49    73    93\n [6,]   16   40   53   73   69   58  103   45   41    64    81\n [7,]   43   84  116  158  112  103  221   71   72   125   156\n [8,]    9   28   36   50   56   45   71   37   32    47    60\n [9,]   11   28   37   51   49   41   72   32   29    45    57\n[10,]   22   48   65   89   73   64  125   47   45    74    93\n[11,]   27   60   81  111   93   81  156   60   57    93   117\n```\n:::\n\n```{.r .cell-code}\n#Inversa de una matriz: solve()\nsolve(Mat_diag)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2]      [,3] [,4] [,5]      [,6]      [,7]  [,8]      [,9] [,10]\n [1,]    1  0.0 0.0000000 0.00  0.0 0.0000000 0.0000000 0.000 0.0000000   0.0\n [2,]    0  0.5 0.0000000 0.00  0.0 0.0000000 0.0000000 0.000 0.0000000   0.0\n [3,]    0  0.0 0.3333333 0.00  0.0 0.0000000 0.0000000 0.000 0.0000000   0.0\n [4,]    0  0.0 0.0000000 0.25  0.0 0.0000000 0.0000000 0.000 0.0000000   0.0\n [5,]    0  0.0 0.0000000 0.00  0.2 0.0000000 0.0000000 0.000 0.0000000   0.0\n [6,]    0  0.0 0.0000000 0.00  0.0 0.1666667 0.0000000 0.000 0.0000000   0.0\n [7,]    0  0.0 0.0000000 0.00  0.0 0.0000000 0.1428571 0.000 0.0000000   0.0\n [8,]    0  0.0 0.0000000 0.00  0.0 0.0000000 0.0000000 0.125 0.0000000   0.0\n [9,]    0  0.0 0.0000000 0.00  0.0 0.0000000 0.0000000 0.000 0.1111111   0.0\n[10,]    0  0.0 0.0000000 0.00  0.0 0.0000000 0.0000000 0.000 0.0000000   0.1\n```\n:::\n\n```{.r .cell-code}\n#Determinante de la matriz: det()\ndet(Mat_diag)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3628800\n```\n:::\n:::\n\n\nEstos anteriores procesos en caso de no cumplir con determinadas caracteristicas no se pueden llevar a cabo, solo se puede invertir matrices que su determinante sea diferente de 0, entre otras caracteristicas.\n\npara acceder a elementos especificos de la matriz debemos hacer uso del indice en formato (x,y) tal que sea (fila, columna)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMAT2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   10   12   14   16   18\n[2,]   11   13   15   17   19\n```\n:::\n\n```{.r .cell-code}\n#Mostrar el elemento ij de la matriz: MAT[i,j]\nMAT2[2,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n\n```{.r .cell-code}\nMAT2[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\npodemos hacer esto tambien para mostrar solo una fila o solo una columna de la matriz\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMAT2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   10   12   14   16   18\n[2,]   11   13   15   17   19\n```\n:::\n\n```{.r .cell-code}\n#Mostrar los elementos de la fila i: MAT[i,]\nMAT2[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 12 14 16 18\n```\n:::\n\n```{.r .cell-code}\n#Mostrar los elmentos de la columna j: MAT[,j]\nMAT2[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 11\n```\n:::\n:::\n\n\npara mejor entendimiento de nuestra matriz podemos cambiarle los nombres a las filas y las columnas, esto nos facilitará el trabajo posterior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(MAT1) = c(\"a\",\"b\",\"c\",\"d\",\"e\")\ncolnames(MAT1) = c(\"f\",\"g\")\nMAT1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  f  g\na 1  2\nb 3  4\nc 5  6\nd 7  8\ne 9 10\n```\n:::\n:::\n\n\n## Operadores logicos y de comparación\n\nLos operadores logicos se utilizan para combinar expresiones lógicas y producir un resultado verdadero o falso. Además, se pueden utilizar los operadores de comparación para crear expresiones lógicas. Los operadores logicos y de comparación entre vectores de las matrices son los siguientes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Elementos mayores o iguales a j en el vector\na>=4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#Elementos menores o iguales a j en el vector\na<=4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n#Elementos iguales a j en el vector\na==4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n#Elementos diferentes a i en el vector\nb!=6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n#Dos afirmaciones verdaderas: \"&\"\na>=1 & b==3 # Recuerden que & es un \"y\" matemático\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n#Al menos una es cierta: \"|\"\na>=1 | b==3 # Recuerden que | es un \"o\" matemático\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\n#Negación: \"!\"\n!a < 0 #a no es menor que cero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n\n## Na y NaN\n\nCuando el codigo nos reporta un dato Na tenemos un missing value, es decir, datos vacios. Por otra parte cuando tenemos un NaN se traduce como un \"non a number\" es decir que el resultado de la operación no se puede calcular dado que es indeterminado\n\n## PENDIENTES\n\nHay que mirar las diferentes colecciones en R y sus metodos respectivos, o en su defecto creo que vectores y matrices son de hecho colecciones de R entonces identarlas con sus respectivos metodos\n\nHay que narrar mejor esta parte\n",
    "supporting": [
      "operaciones_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}